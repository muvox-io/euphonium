{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Euphonium documentation ~ Euphonium is a highly extensible audio streaming software. It's multiplatform, also supporting low cost MCU's like espressif ESP32 series. Features: ~ Clean and lightweight web-ui Supports multiple plugins: Spotify streaming, Bluetooth (on esp32), Web Radio, Jellyfin Fully modular architecture Easily extendible and portable to new hardware, thanks to the internal Berry-lang powered scripting engine. Required hardware for esp32: ~ Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :) Installing a prebuilt version ~ Feel free to try Euphonium by flashing a newest release . All you need to do is to have esptool.py installed on your system (comes with esp-idf). Unpack the euphonium-{version}.tar.gz and run: flash_all.sh {your serial port} to install it. Building Euphonium yourself ~ See here for development setup instructions .","title":"Euphonium documentation"},{"location":"#euphonium-documentation","text":"Euphonium is a highly extensible audio streaming software. It's multiplatform, also supporting low cost MCU's like espressif ESP32 series.","title":"Euphonium documentation"},{"location":"#features","text":"Clean and lightweight web-ui Supports multiple plugins: Spotify streaming, Bluetooth (on esp32), Web Radio, Jellyfin Fully modular architecture Easily extendible and portable to new hardware, thanks to the internal Berry-lang powered scripting engine.","title":"Features:"},{"location":"#required-hardware-for-esp32","text":"Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :)","title":"Required hardware for esp32:"},{"location":"#installing-a-prebuilt-version","text":"Feel free to try Euphonium by flashing a newest release . All you need to do is to have esptool.py installed on your system (comes with esp-idf). Unpack the euphonium-{version}.tar.gz and run: flash_all.sh {your serial port} to install it.","title":"Installing a prebuilt version"},{"location":"#building-euphonium-yourself","text":"See here for development setup instructions .","title":"Building Euphonium yourself"},{"location":"getting-started/","text":"Getting started with Euphonium ~ The fastest way to give euphonium a go is to use prebuilt version from github releases. Required hardware for esp32: ~ Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :) Installing a prebuilt version ~ Flashing a prebuilt version only consists of a few steps: - Download the newest release . (File with name euphonium-vX.X.X.tar.gz ) - Unpack it - Flash it by running sh flash_all.sh {your serial port} - Configuring the system ~ Reboot the board after flashing. After few seconds \"Euphonium\" network should appear. Connect to it. The password is euphonium . You will now be taken to the WiFi configuration page. In case the page does not open automatically - connect to 192.168.4.1 DAC configuration ~ In the \"DAC configuration\" section you can configure the DAC. Euphonium provides an automated configurator for more popular systems. But you can also manually select, and configure the DAC pins. Enjoy your music ~ This is all that's required to get euphonium up and running.","title":"Getting Started"},{"location":"getting-started/#getting-started-with-euphonium","text":"The fastest way to give euphonium a go is to use prebuilt version from github releases.","title":"Getting started with Euphonium"},{"location":"getting-started/#required-hardware-for-esp32","text":"Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :)","title":"Required hardware for esp32:"},{"location":"getting-started/#installing-a-prebuilt-version","text":"Flashing a prebuilt version only consists of a few steps: - Download the newest release . (File with name euphonium-vX.X.X.tar.gz ) - Unpack it - Flash it by running sh flash_all.sh {your serial port} -","title":"Installing a prebuilt version"},{"location":"getting-started/#configuring-the-system","text":"Reboot the board after flashing. After few seconds \"Euphonium\" network should appear. Connect to it. The password is euphonium . You will now be taken to the WiFi configuration page. In case the page does not open automatically - connect to 192.168.4.1","title":"Configuring the system"},{"location":"getting-started/#dac-configuration","text":"In the \"DAC configuration\" section you can configure the DAC. Euphonium provides an automated configurator for more popular systems. But you can also manually select, and configure the DAC pins.","title":"DAC configuration"},{"location":"getting-started/#enjoy-your-music","text":"This is all that's required to get euphonium up and running.","title":"Enjoy your music"},{"location":"hardware/","text":"Hardware ~ Euphonium has been confirmed to work fine with a bunch of hardware. ESP32-Specific Please note that Euphonium officially works on any Linux / MacOS machine. This list is only specific to the ESP32 platform. Officially supported boards ~ All of following boards have a automatic configuration support in he web interface. Ai-Thinker ESP32 Audio-Kit ~ These boards are widely available on different stores for around 10 EUR. Codec differences Older versions of this board come with an AC101 audio codec, while newer ones come with ES8311 . Both versions are supported by Euphonium. Espressif Lyra-T v4.3 ~ Official Espressif's devboard. Powered by ES8311 codec. Officially supported DACs ~ These dacs are supported by euphonium, but require manual pin configuration. ES8311 ~ AC101 ~ TAS5711 ~ Internal DAC of ESP32 ~ MA12070p and MA12040p ~","title":"Hardware"},{"location":"hardware/#hardware","text":"Euphonium has been confirmed to work fine with a bunch of hardware. ESP32-Specific Please note that Euphonium officially works on any Linux / MacOS machine. This list is only specific to the ESP32 platform.","title":"Hardware"},{"location":"hardware/#officially-supported-boards","text":"All of following boards have a automatic configuration support in he web interface.","title":"Officially supported boards"},{"location":"hardware/#ai-thinker-esp32-audio-kit","text":"These boards are widely available on different stores for around 10 EUR. Codec differences Older versions of this board come with an AC101 audio codec, while newer ones come with ES8311 . Both versions are supported by Euphonium.","title":"Ai-Thinker ESP32 Audio-Kit"},{"location":"hardware/#espressif-lyra-t-v43","text":"Official Espressif's devboard. Powered by ES8311 codec.","title":"Espressif Lyra-T v4.3"},{"location":"hardware/#officially-supported-dacs","text":"These dacs are supported by euphonium, but require manual pin configuration.","title":"Officially supported DACs"},{"location":"hardware/#es8311","text":"","title":"ES8311"},{"location":"hardware/#ac101","text":"","title":"AC101"},{"location":"hardware/#tas5711","text":"","title":"TAS5711"},{"location":"hardware/#internal-dac-of-esp32","text":"","title":"Internal DAC of ESP32"},{"location":"hardware/#ma12070p-and-ma12040p","text":"","title":"MA12070p and MA12040p"},{"location":"plugins/","text":"Plugins ~ Euphonium integrates with a number of plugins that extend its functionality. WebRadio ~ This plugin adds support for streaming radios from the internet. It provides a simple web interface for searching through different radio stations, powered by radio-browser.info . Spotify ~ This plugin turns Euphonium into a Spotify-Connect speaker. It allows you to stream audio from their vast audio library, and control it from the spotify apps. Powered by cspot . Warning - this requires Spotify premium Bluetooth ~ (esp32 only) Makes Euphonium act as a Bluetooth A2DP speaker. Simply connect to it, and play your favorite music. Jellyfin ~ Planned plugins ~ AirPlay YouTube / ChromeCast simulator via DIAL Snapcast client Snapcast server","title":"Plugins"},{"location":"plugins/#plugins","text":"Euphonium integrates with a number of plugins that extend its functionality.","title":"Plugins"},{"location":"plugins/#webradio","text":"This plugin adds support for streaming radios from the internet. It provides a simple web interface for searching through different radio stations, powered by radio-browser.info .","title":"WebRadio"},{"location":"plugins/#spotify","text":"This plugin turns Euphonium into a Spotify-Connect speaker. It allows you to stream audio from their vast audio library, and control it from the spotify apps. Powered by cspot . Warning - this requires Spotify premium","title":"Spotify"},{"location":"plugins/#bluetooth","text":"(esp32 only) Makes Euphonium act as a Bluetooth A2DP speaker. Simply connect to it, and play your favorite music.","title":"Bluetooth"},{"location":"plugins/#jellyfin","text":"","title":"Jellyfin"},{"location":"plugins/#planned-plugins","text":"AirPlay YouTube / ChromeCast simulator via DIAL Snapcast client Snapcast server","title":"Planned plugins"},{"location":"status/","text":"Status ~ Euphonium is currently in state of rapid development. Roadmap ~ As of January 2022, most of the core functionality is already implemented. Currently in feature freeze until end of January, in order to prepare the system for wider use. January: Setup a documentation page. Get basic infrastucture working via GitHub. Setup reference API for berry and HTTP API. Feburary: Stabilize Spotify, WebRadio and Bluetooth functionality. Assemble some basic hardware, test out battery efficiency. Try to get more feedback on the platform. March - [x] Design and implement new web interface - [x] Provide more mature hardware APIs - [x] Mobile app as scanner - [ ] Implement snapcast client (in progress) TODO - [ ] YouTube client - [ ] Test vendor APIs","title":"Status"},{"location":"status/#status","text":"Euphonium is currently in state of rapid development.","title":"Status"},{"location":"status/#roadmap","text":"As of January 2022, most of the core functionality is already implemented. Currently in feature freeze until end of January, in order to prepare the system for wider use. January: Setup a documentation page. Get basic infrastucture working via GitHub. Setup reference API for berry and HTTP API. Feburary: Stabilize Spotify, WebRadio and Bluetooth functionality. Assemble some basic hardware, test out battery efficiency. Try to get more feedback on the platform. March - [x] Design and implement new web interface - [x] Provide more mature hardware APIs - [x] Mobile app as scanner - [ ] Implement snapcast client (in progress) TODO - [ ] YouTube client - [ ] Test vendor APIs","title":"Roadmap"},{"location":"http/","text":"Euphonium REST API ~ By it's design, Euphonium is a modular system. The REST API consists of the main set of endpoints available on every system, and then of endpoints defined by given plugins.","title":"Euphonium REST API"},{"location":"http/#euphonium-rest-api","text":"By it's design, Euphonium is a modular system. The REST API consists of the main set of endpoints available on every system, and then of endpoints defined by given plugins.","title":"Euphonium REST API"},{"location":"http/devtools/","text":"DevTools Plugin API ~ Extension of Euphonium REST API. This plugin provides an API that allows for modification of the internal scripts, a functionality required by th web-ide. Events ~ This plugin does not provide custom events. DevTools ~ GET /devtools/file ~ Returns list of all files available in the scripts filesystem. Parameters ~ This endpoint does not take any parameters. Response ~ Returns list of files Response type application/json [ \"app.be\" , \"init.be\" , \"esp32/dac.be\" ] POST /devtools/file/:filePath ~ Updates content of the file under filePath . In case of file not existing, it creates one. Parameters ~ Parameter type Description filePath path Path to the file, including name body body Contents of the file Response ~ Returns list of files Response type application/json [ \"app.be\" , \"init.be\" , \"esp32/dac.be\" ] GET /devtools/logs ~ Returns newest logfile. Parameters ~ This endpoint does not take any parameters. Response ~ Returns logs Response type text/plain . This response is not a json, its just a list of logs split by a newline. I [cspot] ZeroconfAuthenticator.cpp:26: Got request for info I [cspot] ZeroconfAuthenticator.cpp:26: Got request for info I [cspot] ZeroconfAuthenticator.cpp:26: Got request for info I [persistor] ConfigPersistor.cpp:71: Sending file: index.html I [persistor] ConfigPersistor.cpp:71: Sending file: assets/index.4aec51d4.css I [persistor] ConfigPersistor.cpp:71: Sending file: assets/index.a6e012ba.js I [persistor] ConfigPersistor.cpp:71: Sending file: assets/vendor.0e1590e8.js","title":"Plugin - DevTools"},{"location":"http/devtools/#devtools-plugin-api","text":"Extension of Euphonium REST API. This plugin provides an API that allows for modification of the internal scripts, a functionality required by th web-ide.","title":"DevTools Plugin API"},{"location":"http/devtools/#events","text":"This plugin does not provide custom events.","title":"Events"},{"location":"http/devtools/#devtools","text":"","title":"DevTools"},{"location":"http/devtools/#get-devtoolsfile","text":"Returns list of all files available in the scripts filesystem.","title":"GET /devtools/file"},{"location":"http/devtools/#post-devtoolsfilefilepath","text":"Updates content of the file under filePath . In case of file not existing, it creates one.","title":"POST /devtools/file/:filePath"},{"location":"http/devtools/#get-devtoolslogs","text":"Returns newest logfile.","title":"GET /devtools/logs"},{"location":"http/main/","text":"Euphonium REST API ~ Every instance of the player exposes a HTTP API, internally used by the web-ui and the web-ide. This API is accessible under the default port. Warning This API is not stable yet, and may change in the future. In particular, authentication is not implemented at this moment. Events ~ Euphonium's HTTP server exposes a endpoint for receiving live events. The events are sent as JSON objects. This is implemented as a long-lived connection to the /events endpoint. This is used for real time updates in the web ide. Plugins ~ Manages internal plugins. GET /plugins ~ Returns list of currently active plugins. Parameters ~ This endpoint does not have parameters Responses ~ Returns list of plugins Response type application/json [ { \"type\" : \"plugin\" , \"name\" : \"cspot\" , \"displayName\" : \"Spotify (cspot)\" }, { \"type\" : \"plugin\" , \"name\" : \"webradio\" , \"displayName\" : \"WebRadio\" }, { \"type\" : \"app\" , \"name\" : \"webradio\" , \"displayName\" : \"WebRadio\" }, ] GET /plugins/:pluginName ~ Returns configuration schema with current values for given plugin. Parameters ~ Parameter type Description pluginName path string Name of the plugin to retrieve configuration of. Responses ~ Returns plugin configuration Response type application/json . Example of spotify. { \"configSchema\" : { \"audioBitrate\" : { \"value\" : \"160\" , \"tooltip\" : \"Audio bitrate\" , \"type\" : \"stringList\" , \"defaultValue\" : \"160\" , \"listValues\" : [ \"96\" , \"160\" , \"320\" ] }, \"receiverName\" : { \"tooltip\" : \"Speaker's name\" , \"type\" : \"string\" , \"value\" : \"Euphonium (cspot)\" , \"defaultValue\" : \"Euphonium (cspot)\" } }, \"themeColor\" : \"#1DB954\" , \"displayName\" : \"Spotify (cspot)\" } POST /plugins/:pluginName ~ Updates configuration of given plugin schema. This configuration is persisted between reboots. Parameters ~ Parameter type Description pluginName path string Name of the plugin to retrieve configuration of. body body PluginConfig Content described below. Requests ~ Change spotify configuration Response type application/json . { \"audioBitrate\" : \"320\" , \"receiverName\" : \"Living room\\'s speaker\" } Responses ~ Returns plugin configuration Request type application/json . Example of spotify. { \"configSchema\" : { \"audioBitrate\" : { \"value\" : \"320\" , \"tooltip\" : \"Audio bitrate\" , \"type\" : \"stringList\" , \"defaultValue\" : \"160\" , \"listValues\" : [ \"96\" , \"160\" , \"320\" ] }, \"receiverName\" : { \"tooltip\" : \"Speaker's name\" , \"type\" : \"string\" , \"value\" : \"Living room\\'s speaker\" , \"defaultValue\" : \"Euphonium (cspot)\" } }, \"themeColor\" : \"#1DB954\" , \"displayName\" : \"Spotify (cspot)\" } Playback ~ Manages the playback state of the system. GET /playback ~ Returns complete current state of playback, containing current track, current position, current volume and current eq settings. Parameters ~ This endpoint does not have parameters Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"paused\" , \"volume\" : 50 , \"eq\" : { \"low\" : 0 , \"mid\" : -0.5 , \"high\" : 0 } } POST /playback/volume ~ Updates playback current volume. Parameters ~ Parameter type Description body body Volume Content described below. Requests ~ Change volume Request type application/json . Volume is an integer betwen 0 and 100. { \"volume\" : 100 , } Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"paused\" , \"volume\" : 100 , \"eq\" : { \"low\" : 0 , \"mid\" : -0.5 , \"high\" : 0 } } POST /playback/eq ~ Updates playback current equalizer settings. Parameters ~ Parameter type Description body body Eq Content described below. Requests ~ Change equalizer settings Request type application/json . Equalizer settings are an object with keys low , mid and high . One value on the scale corresponds to 3 dB. { \"low\" : 1.25 , \"mid\" : 0 , \"high\" : 0 } Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"paused\" , \"volume\" : 100 , \"eq\" : { \"low\" : 1.25 , \"mid\" : 0 , \"high\" : 0 } } POST /playback/status ~ Updates playback current playback status. Parameters ~ Parameter type Description body body Playback Content described below. Requests ~ Change playback settings Request type application/json . Status is either 'playing' or 'paused' { \"status\" : \"playing\" } Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"playing\" , \"volume\" : 100 , \"eq\" : { \"low\" : 1.25 , \"mid\" : 0 , \"high\" : 0 } } System ~ Manages the state of the system. GET /system ~ Returns information about current system state. Parameters ~ This endpoint does not have parameters Responses ~ Returns current system state Response type application/json . { \"networkState\" : \"online\" , \"version\" : \"0.0.14\" } POST /system/reboot ~ Returns information about current system state. Parameters ~ Calling this endpoint will reboot the system. Responses ~ Returns current system state Response type application/json . { \"version\" : \"0.0.14\" , \"networkState\" : \"rebooting\" , } WiFi ~ Manages state of the WiFi connection GET /wifi ~ Returns current WiFi state. Parameters ~ This endpoint does not have parameters Responses ~ Returns current WiFi state Response type application/json . Example of connected to AP. { \"state\" : \"connected\" , \"ipAddress\" : \"192.168.254.103\" } POST /wifi/connect ~ Connects to WiFi network. Parameters ~ Parameter type Description body body WiFiSettings Content described below. Requests ~ WiFi network parameters Request type application/json . { \"ssid\" : \"RandomNetwork\" , \"password\" : \"Test123\" } Responses ~ Returns current WiFi state Response type application/json . Example of connected to AP. { \"state\" : \"connecting\" , } POST /wifi/scan_start ~ Starts WiFi network scan. Parameters ~ This endpoint does not have parameters Responses ~ Returns current WiFi state Response type application/json . Example of connected to AP. { \"state\" : \"scanning\" , }","title":"Core"},{"location":"http/main/#euphonium-rest-api","text":"Every instance of the player exposes a HTTP API, internally used by the web-ui and the web-ide. This API is accessible under the default port. Warning This API is not stable yet, and may change in the future. In particular, authentication is not implemented at this moment.","title":"Euphonium REST API"},{"location":"http/main/#events","text":"Euphonium's HTTP server exposes a endpoint for receiving live events. The events are sent as JSON objects. This is implemented as a long-lived connection to the /events endpoint. This is used for real time updates in the web ide.","title":"Events"},{"location":"http/main/#plugins","text":"Manages internal plugins.","title":"Plugins"},{"location":"http/main/#get-plugins","text":"Returns list of currently active plugins.","title":"GET /plugins"},{"location":"http/main/#get-pluginspluginname","text":"Returns configuration schema with current values for given plugin.","title":"GET /plugins/:pluginName"},{"location":"http/main/#post-pluginspluginname","text":"Updates configuration of given plugin schema. This configuration is persisted between reboots.","title":"POST /plugins/:pluginName"},{"location":"http/main/#playback","text":"Manages the playback state of the system.","title":"Playback"},{"location":"http/main/#get-playback","text":"Returns complete current state of playback, containing current track, current position, current volume and current eq settings.","title":"GET /playback"},{"location":"http/main/#post-playbackvolume","text":"Updates playback current volume.","title":"POST /playback/volume"},{"location":"http/main/#post-playbackeq","text":"Updates playback current equalizer settings.","title":"POST /playback/eq"},{"location":"http/main/#post-playbackstatus","text":"Updates playback current playback status.","title":"POST /playback/status"},{"location":"http/main/#system","text":"Manages the state of the system.","title":"System"},{"location":"http/main/#get-system","text":"Returns information about current system state.","title":"GET /system"},{"location":"http/main/#post-systemreboot","text":"Returns information about current system state.","title":"POST /system/reboot"},{"location":"http/main/#wifi","text":"Manages state of the WiFi connection","title":"WiFi"},{"location":"http/main/#get-wifi","text":"Returns current WiFi state.","title":"GET /wifi"},{"location":"http/main/#post-wificonnect","text":"Connects to WiFi network.","title":"POST /wifi/connect"},{"location":"http/main/#post-wifiscan_start","text":"Starts WiFi network scan.","title":"POST /wifi/scan_start"},{"location":"http/ota/","text":"OTA Plugin API ~ Extension of Euphonium REST API. This plugin provides an API for OTA updates on the esp32 platform. Events ~ This plugin does not provide custom events. OTA ~ POST /ota ~ This endpoint sets the URL and sha256 of the firmware image to be downloaded, and reboots the device into recovery. Parameters ~ Parameter type Description body body OTA Content described below. Requests ~ Set OTA url and it's sha256 Request type application/json . { \"url\" : \"https://github.com/feelfreelinux/euphonium/releases/download/v0.0.14/ota.bin\" , \"sha256\" : \"e25ec6490d7cf480a26b5f18d7a50b8a7db247b18da749f3d938e8581bf92e22\" } Responses ~ Returns update OTA manifest Response type application/json { \"url\" : \"https://github.com/feelfreelinux/euphonium/releases/download/v0.0.14/ota.bin\" , \"sha256\" : \"e25ec6490d7cf480a26b5f18d7a50b8a7db247b18da749f3d938e8581bf92e22\" }","title":"Plugin - OTA"},{"location":"http/ota/#ota-plugin-api","text":"Extension of Euphonium REST API. This plugin provides an API for OTA updates on the esp32 platform.","title":"OTA Plugin API"},{"location":"http/ota/#events","text":"This plugin does not provide custom events.","title":"Events"},{"location":"http/ota/#ota","text":"","title":"OTA"},{"location":"http/ota/#post-ota","text":"This endpoint sets the URL and sha256 of the firmware image to be downloaded, and reboots the device into recovery.","title":"POST /ota"},{"location":"http/webradio/","text":"WebRadio Plugin API ~ Extension of Euphonium REST API. This plugin provides playback of different HTTP audio streams. Events ~ This plugin does not provide custom events. WebRadio ~ POST /webradio ~ In case of another audio source playing, this triggers the web radio source and plays radio with given parameters. Parameters ~ Parameter type Description body body WebRadio Content described below. Requests ~ Set radio url to play Request type application/json . { \"coverImage\" : \"http://example.com/radio.jpeg\" , \"url\" : \"http://example.com/radio.mp3\" , \"codec\" : \"MP3\" , \"name\" : \"Example Radio\" , } Responses ~ Returns set radio settings Response type application/json . { \"coverImage\" : \"http://example.com/radio.jpeg\" , \"url\" : \"http://example.com/radio.mp3\" , \"codec\" : \"MP3\" , \"name\" : \"Example Radio\" , }","title":"Plugin - WebRadio"},{"location":"http/webradio/#webradio-plugin-api","text":"Extension of Euphonium REST API. This plugin provides playback of different HTTP audio streams.","title":"WebRadio Plugin API"},{"location":"http/webradio/#events","text":"This plugin does not provide custom events.","title":"Events"},{"location":"http/webradio/#webradio","text":"","title":"WebRadio"},{"location":"http/webradio/#post-webradio","text":"In case of another audio source playing, this triggers the web radio source and plays radio with given parameters.","title":"POST /webradio"},{"location":"plugins/scripting-language/","text":"Scripting language API ~ Euphonium contains a berry-lang scripting language that can be used to tweak the system for your needs. The following page documents the internal API used in all scripts. Feel free to check euphonium/scripts to see how this is used internally. globals ~ Global utilities Commands ~ Command Signature Supported platforms sleep_ms (milliseconds: int) -> void . Pauses execution for given amount of milliseconds. All core ~ Manages euphonium's core functionality, mostly shared utils. Implemented by Core.cpp Commands ~ Command Signature Supported platforms core.start_plugin (pluginName: string, pluginConfig: map) -> void Starts given plugin's audio thread with following configuration. All core.platform () -> string . Returns platform on which euphonium is currently running. Result being either esp32 or desktop All core.version () -> string . Returns current version of the system. Example result: 0.0.14 All FormContext ~ Class used in plugins that handles UI creation and interaction in the web-ui. Implemented by form_ctx.be Class methods ~ All of the following methods are available on the FormContext class instance. Command Signature Supported platforms text_field (key: string, config: FieldConfig) -> void Adds a text field to the configuration. See FieldConfig below for parameters. All select_field (key: string, config: FieldConfig) -> void Adds a option select / picker field to the configuration. See FieldConfig below for parameters. All checkbox_field (key: string, config: FieldConfig) -> void Adds a checkbox to the configuration. See FieldConfig below for parameters. All create_group (key: string, config: [key: string, label: string]) -> void Adds a new config group to the configuration. All Interface FieldConfig ~ Field Signature Field type label string Configuration field's label visible over the control in the interface. All hint string Used as a hint in the text field. text_field default string Field's default value. All values list All of select field's available values. select_field group string Group that a given field belongs to, previously registered with create_group All http ~ Allows for registering endpoints on the internal HTTP server. Implemented by http.be and HTTPModule.cpp Commands ~ Command Signature Supported platforms http.handle (method: string, path: string, response_handler: [(request) -> void]) -> void Register a new HTTP endpoint under given path . Response handler is a method that takes HTTPRequest as a parameter. See examples below for usage. All http.emit_event (type: string, body: map) -> void . Broadcasts a server-side event to all connected devices. body will be serialized into json string. All Object HTTPRequest ~ Command Signature Supported platforms write_json (body: map, status: int) -> void . Writes a response json to given connection. Body is passed as a map of data to be serialized into json. Status is the HTTP status code of the response. All write_text (body: string, status: int) -> void . Writes the response as text/plain . All json_body () -> map Parses given request's body string into json and returns it as map All query_params () -> map Returns map of parsed query parameters of the given request. All url_params () -> map Returns map of parsed url parameters of the given request. All Example ~ HTTP server usage Handle simple GET and return \"Hello, world!\" http . handle ( 'GET' , '/hello_world' , def ( request ) request . write_text ( \"Hello world!\" , 200 ) end ) Handle POST with json body, return a json response http . handle ( 'POST' , '/create_cat' , def ( request ) if request . json_body () == nil http . write_text ( \"No body\" , request [ 'connection' ], 400 ) else # Parse json body var parsed_body = request . json_body () # Create response var response = { 'name' : parsed_body [ 'name' ], 'age' : 3 } request . write_json ( response , 200 ) end end ) playback ~ Manages playback state of the system. Commands ~ Command Signature Supported platforms playback.set_eq (low: int, mid: int, high: int) -> void . If EqualizerProcessor is enabled, this changes the eq's settings. 1 point on the scale means 3 db. Defaults to 0, 0, 0 (no eq). All playback.set_pause (paused: boolean) -> void . Pauses the playback state. This also triggers a pause event. All playback.empty_buffers () -> void . Empties internal audio buffers of the system. Call this during playback changes / stop pause. All playback.soft_volume (volume: int) -> void Changes the system's software volume. Volume is between 0 and 100 . All euphonium ~ Global euphonium instance object. Handles main events, and keeps a state of plugin registry. Commands ~ Command Signature Supported platforms euphonium.register_plugin (plugin: Plugin) -> void Registers a new euphonium plugin. plugin is a instance of plugin to register in the system. All input ~ ESP32 specific Allows registration of callbacks for input events. Useful for adding buttons, encoders and such. Commands ~ Command Signature Supported platforms hooks ~ Hooks allow to run different instructions during certain boot stages. Used for example to pull up an IO during boot. Commands ~ Command Signature Supported platforms hooks.add_handler (bootstage: int, handler: [() -> void]) -> void Register a new hook. Different bootstage values described below. All enum hooks.BOOTSTAGE ~ Command Description Supported platforms hooks.ON_INIT Called earliest during boot, after scripting VM init. All hooks.POST_SYSTEM Called after all core logic has been initialized, before plugins startup. All hooks.POST_PLUGIN Called after all plugins have been initialized All hooks.AP_INIT Called after AP network has been initialized. esp32 hooks.WIFI_INIT Called after WiFi has been initialized. esp32 Example ~ Sample hook that runs after boot Define I2S configuration, output 256 x MCLK clock on GPIO0. hooks . add_handler ( hooks . ON_INIT , def () print ( \"On boot called!\" ) end ) i2s ~ Controls I2S bus. Mainly used for DAC support. Implemented by I2SDriver.cpp Commands ~ Command Signature Supported platforms i2s.install (configuration: I2SConfig) -> void Installs I2S driver. See below for description of I2SConfig structure. esp32 i2s.delete () -> void . Uninstalls the current I2S driver. esp32 i2s.set_expand (src: int, dst: int) -> void . Enables expand from src bits to dst bits in driver write. Useful for 32bit DAC support. esp32 i2s.disable_expand () -> void . Disables bits expand. esp32 Object I2SConfig ~ Field Description sample_rate int Defines sample rate for the incoming data signal. WARNING - Sample rate is only initial, will be further changed in case od dynamic sample rate bits_per_sample int Bits per sample for incoming data. comm_format one of I2S_CHANNEL_FMT_RIGHT_LEFT , I2S_CHANNEL_FMT_ALL_RIGHT , I2S_CHANNEL_FMT_ALL_LEFT or I2S_CHANNEL_FMT_ONLY_RIGHT channel_format one of I2S_COMM_FORMAT_I2S , I2S_COMM_FORMAT_MSB , I2S_COMM_FORMAT_PCM_SHORT or I2S_COMM_FORMAT_PCM_LONG mclk int if defined and larger than 0, outputs given mclk on GPIO0. Example ~ Sample driver configuration Define I2S configuration, output 256 x MCLK clock on GPIO0. var config = I2SConfig () config . sample_rate = 44100 config . bits_per_sample = 16 config . comm_format = I2S_CHANNEL_FMT_RIGHT_LEFT config . channel_format = I2S_COMM_FORMAT_I2S config . mclk = 256 * 44100 i2s . install ( config ) i2c ~ Controls I2C bus on supported platforms. Mainly used in different drivers. Implemented by I2CDriver.cpp Commands ~ Command Signature Supported platforms i2c.install (sda: int, scl: int) -> void Installs I2C driver under given pins. esp32 i2c.detect (addr:int) -> bool . Tries to detect device under given addr. Returns true if device found. esp32 i2c.read_bytes (addr:int, reg:int, size:int) -> int or nil . Read a value of 1..4 bytes from address addr and register reg. Returns nil if no response. esp32 i2c.write_bytes (addr:int, reg:int, val:bytes) -> nil Writes the val bytes sequence as bytes() to address addr register reg. esp32 i2c.read (addr:int, reg:int, size:int) -> int or nil . Reads a singular bytes from a given register. esp32 i2c.write (addr:int, reg:int, val:int) -> nil Writes a singular byte to a given register. esp32 i2c.write_raw (addr:int, val:bytes) -> nil Write a raw sequence of bytes to the given device. esp32 i2c.read_raw (addr:int, val:bytes, size: int) -> int or nil Writes the val sequence of bytes on the i2c line, and then reads size bytes. esp32 Example ~ Write few bytes to I2C device Configure I2C on 21 and 23 pins, then perform two writes. i2c . install ( 21 , 23 ) var deviceAddr = 0x10 # Write 0x01 to register 0x00 i2c . write ( deviceAddr , 0x00 , 0x01 ) # Write byte sequence to register 0x01 i2c . write_bytes ( deviceAddr , 0x01 , bytes ( '1a01' )) gpio ~ Controls GPIO pins on supported platforms. Mainly used in different drivers. Implemented by GPIODriver.cpp Commands ~ Command Signature Supported platforms gpio.digital_write (gpio: int, state: int) -> void Sets GPIO to LOW/HIGH. Needs physical pin number esp32 gpio.digital_read (gpio: int) -> int Returns digital state of given physical GPIO. Either gpio.LOW or gpio.HIGH esp32 gpio.pin_mode (gpio: int, mode: int) -> int Changes the GPIO mode. Only use if if you know what you're doing, by default Euphonium handles GPIO mode itself. Mode can have the following values: gpio.INPUT, gpio.OUTPUT, gpio.PULLUP, gpio.INPUT_PULLUP, gpio.PULLDOWN esp32 gpio.analog_read (gpio: int) -> real . Returns the voltage on a given pin in mV. Only used with DAC pins. esp32 gpio.register_button (gpio: int, event_type: gpio.EVENT_TYPE, handler: [() -> void], config: map([high_state: bool])) -> void Registers a new handler called after interaction with a given button on provided gpio . Supports press, double press, and long press. esp32 enum input.EVENT_TYPE ~ Command Description Supported platforms gpio.PRESS Called on single press of a button. esp32 gpio.DOUBLE_PRESS Called on double press of a button. esp32 gpio.LONG_PRESS Called on long press of a button. esp32 Example ~ GPIO Driver usage Sets GPIO 21 as output, writes its state to HIGH. gpio . pin_mode ( 21 , gpio . OUTPUT ) gpio . digital_write ( 21 , gpio . HIGH ) Example ~ Example button that changes volume when pressed Register a button on gpio 5, and call a function from playback when pressed. gpio . register_button ( 5 , input . PRESS , def () print ( \"Volume up called!\" ) playback . set_volume ( playback . volume + 5 ) end , { 'high_state' : true }) led_strip ~ Allows for control of addressable LEDs like the WS28xx and SK6812. Underneath it uses esp32's RMT driver, to drive up to 8 separate strip instances. Implemented by LEDDriver.cpp Class LEDStrip ~ Field Signature Supported platforms init / constructor (type: LED_TYPE, pin: int, len: int, channel: RMT_CHANNEL, brightness: int?) LEDStrip constructor. Allows control of a singular strip, with a driver type , connected under a GPIO pin . channel is the RMT channel to use. If brightness is provided, the entire LED chain will be dimmed accordingly. esp32 show () -> void Called on existing instance. Will update the LED strip with previously assigned color values esp32 set_item (index, item: [r: number, g: number, b: number]) -> void This implements the API for setting color of individual LEDs via a standard color assign. See example below for usage. r , g and b range from 0 to 255. esp32 enum led_strip.LED_TYPE ~ Value Description LED_WS2812 Indicates WS2812 LED type. LED_WS2812B Indicates WS2812B LED type. LED_SK6812 Indicates SK6812 LED type. LED_WS2813 Indicates WS2813 LED type. Example ~ LED Driver usage Registers a new LED strip under pin 21, consisting of 12 WS2812 leds, at lower brightness. Then turns the first LED red, the second one green. volume_strip = LEDStrip ( LED_WS2812 , 21 , 12 , RMT_CHANNEL_0 , 150 ) # change the first LED to red and second one to green. volume_strip [ 0 ] = [ 255 , 0 , 0 ] # red in RGB format volume_strip [ 1 ] = [ 0 , 255 , 0 ] # green in RGB format # display the changes on the strip volume_strip . show () wifi ~ Controls internal state of the platform's WiFi. Used internally by wifi.be . Implemented by WiFiDriver.cpp Commands ~ Command Signature Supported platforms wifi.init_stack () -> void Initializes the WiFi stack esp32 wifi.connect (ssid: string, password: string, fromAP: bool) -> void Attempts WiFi connection. fromAP should be set according to the current WiFi mode. esp32 wifi.start_ap (ssid: string, password: string) -> void Starts an access point with given credentials. esp32 wifi.start_scan () -> boid . Starts scanning of WiFi networks. esp32","title":"Scripting Language"},{"location":"plugins/scripting-language/#scripting-language-api","text":"Euphonium contains a berry-lang scripting language that can be used to tweak the system for your needs. The following page documents the internal API used in all scripts. Feel free to check euphonium/scripts to see how this is used internally.","title":"Scripting language API"},{"location":"plugins/scripting-language/#globals","text":"Global utilities","title":"globals"},{"location":"plugins/scripting-language/#commands","text":"Command Signature Supported platforms sleep_ms (milliseconds: int) -> void . Pauses execution for given amount of milliseconds. All","title":"Commands"},{"location":"plugins/scripting-language/#core","text":"Manages euphonium's core functionality, mostly shared utils. Implemented by Core.cpp","title":"core"},{"location":"plugins/scripting-language/#commands_1","text":"Command Signature Supported platforms core.start_plugin (pluginName: string, pluginConfig: map) -> void Starts given plugin's audio thread with following configuration. All core.platform () -> string . Returns platform on which euphonium is currently running. Result being either esp32 or desktop All core.version () -> string . Returns current version of the system. Example result: 0.0.14 All","title":"Commands"},{"location":"plugins/scripting-language/#formcontext","text":"Class used in plugins that handles UI creation and interaction in the web-ui. Implemented by form_ctx.be","title":"FormContext"},{"location":"plugins/scripting-language/#class-methods","text":"All of the following methods are available on the FormContext class instance. Command Signature Supported platforms text_field (key: string, config: FieldConfig) -> void Adds a text field to the configuration. See FieldConfig below for parameters. All select_field (key: string, config: FieldConfig) -> void Adds a option select / picker field to the configuration. See FieldConfig below for parameters. All checkbox_field (key: string, config: FieldConfig) -> void Adds a checkbox to the configuration. See FieldConfig below for parameters. All create_group (key: string, config: [key: string, label: string]) -> void Adds a new config group to the configuration. All","title":"Class methods"},{"location":"plugins/scripting-language/#interface-fieldconfig","text":"Field Signature Field type label string Configuration field's label visible over the control in the interface. All hint string Used as a hint in the text field. text_field default string Field's default value. All values list All of select field's available values. select_field group string Group that a given field belongs to, previously registered with create_group All","title":"Interface FieldConfig"},{"location":"plugins/scripting-language/#http","text":"Allows for registering endpoints on the internal HTTP server. Implemented by http.be and HTTPModule.cpp","title":"http"},{"location":"plugins/scripting-language/#commands_2","text":"Command Signature Supported platforms http.handle (method: string, path: string, response_handler: [(request) -> void]) -> void Register a new HTTP endpoint under given path . Response handler is a method that takes HTTPRequest as a parameter. See examples below for usage. All http.emit_event (type: string, body: map) -> void . Broadcasts a server-side event to all connected devices. body will be serialized into json string. All","title":"Commands"},{"location":"plugins/scripting-language/#object-httprequest","text":"Command Signature Supported platforms write_json (body: map, status: int) -> void . Writes a response json to given connection. Body is passed as a map of data to be serialized into json. Status is the HTTP status code of the response. All write_text (body: string, status: int) -> void . Writes the response as text/plain . All json_body () -> map Parses given request's body string into json and returns it as map All query_params () -> map Returns map of parsed query parameters of the given request. All url_params () -> map Returns map of parsed url parameters of the given request. All","title":"Object HTTPRequest"},{"location":"plugins/scripting-language/#example","text":"HTTP server usage Handle simple GET and return \"Hello, world!\" http . handle ( 'GET' , '/hello_world' , def ( request ) request . write_text ( \"Hello world!\" , 200 ) end ) Handle POST with json body, return a json response http . handle ( 'POST' , '/create_cat' , def ( request ) if request . json_body () == nil http . write_text ( \"No body\" , request [ 'connection' ], 400 ) else # Parse json body var parsed_body = request . json_body () # Create response var response = { 'name' : parsed_body [ 'name' ], 'age' : 3 } request . write_json ( response , 200 ) end end )","title":"Example"},{"location":"plugins/scripting-language/#playback","text":"Manages playback state of the system.","title":"playback"},{"location":"plugins/scripting-language/#commands_3","text":"Command Signature Supported platforms playback.set_eq (low: int, mid: int, high: int) -> void . If EqualizerProcessor is enabled, this changes the eq's settings. 1 point on the scale means 3 db. Defaults to 0, 0, 0 (no eq). All playback.set_pause (paused: boolean) -> void . Pauses the playback state. This also triggers a pause event. All playback.empty_buffers () -> void . Empties internal audio buffers of the system. Call this during playback changes / stop pause. All playback.soft_volume (volume: int) -> void Changes the system's software volume. Volume is between 0 and 100 . All","title":"Commands"},{"location":"plugins/scripting-language/#euphonium","text":"Global euphonium instance object. Handles main events, and keeps a state of plugin registry.","title":"euphonium"},{"location":"plugins/scripting-language/#commands_4","text":"Command Signature Supported platforms euphonium.register_plugin (plugin: Plugin) -> void Registers a new euphonium plugin. plugin is a instance of plugin to register in the system. All","title":"Commands"},{"location":"plugins/scripting-language/#input","text":"ESP32 specific Allows registration of callbacks for input events. Useful for adding buttons, encoders and such.","title":"input"},{"location":"plugins/scripting-language/#commands_5","text":"Command Signature Supported platforms","title":"Commands"},{"location":"plugins/scripting-language/#hooks","text":"Hooks allow to run different instructions during certain boot stages. Used for example to pull up an IO during boot.","title":"hooks"},{"location":"plugins/scripting-language/#commands_6","text":"Command Signature Supported platforms hooks.add_handler (bootstage: int, handler: [() -> void]) -> void Register a new hook. Different bootstage values described below. All","title":"Commands"},{"location":"plugins/scripting-language/#enum-hooksbootstage","text":"Command Description Supported platforms hooks.ON_INIT Called earliest during boot, after scripting VM init. All hooks.POST_SYSTEM Called after all core logic has been initialized, before plugins startup. All hooks.POST_PLUGIN Called after all plugins have been initialized All hooks.AP_INIT Called after AP network has been initialized. esp32 hooks.WIFI_INIT Called after WiFi has been initialized. esp32","title":"enum hooks.BOOTSTAGE"},{"location":"plugins/scripting-language/#example_1","text":"Sample hook that runs after boot Define I2S configuration, output 256 x MCLK clock on GPIO0. hooks . add_handler ( hooks . ON_INIT , def () print ( \"On boot called!\" ) end )","title":"Example"},{"location":"plugins/scripting-language/#i2s","text":"Controls I2S bus. Mainly used for DAC support. Implemented by I2SDriver.cpp","title":"i2s"},{"location":"plugins/scripting-language/#commands_7","text":"Command Signature Supported platforms i2s.install (configuration: I2SConfig) -> void Installs I2S driver. See below for description of I2SConfig structure. esp32 i2s.delete () -> void . Uninstalls the current I2S driver. esp32 i2s.set_expand (src: int, dst: int) -> void . Enables expand from src bits to dst bits in driver write. Useful for 32bit DAC support. esp32 i2s.disable_expand () -> void . Disables bits expand. esp32","title":"Commands"},{"location":"plugins/scripting-language/#object-i2sconfig","text":"Field Description sample_rate int Defines sample rate for the incoming data signal. WARNING - Sample rate is only initial, will be further changed in case od dynamic sample rate bits_per_sample int Bits per sample for incoming data. comm_format one of I2S_CHANNEL_FMT_RIGHT_LEFT , I2S_CHANNEL_FMT_ALL_RIGHT , I2S_CHANNEL_FMT_ALL_LEFT or I2S_CHANNEL_FMT_ONLY_RIGHT channel_format one of I2S_COMM_FORMAT_I2S , I2S_COMM_FORMAT_MSB , I2S_COMM_FORMAT_PCM_SHORT or I2S_COMM_FORMAT_PCM_LONG mclk int if defined and larger than 0, outputs given mclk on GPIO0.","title":"Object I2SConfig"},{"location":"plugins/scripting-language/#example_2","text":"Sample driver configuration Define I2S configuration, output 256 x MCLK clock on GPIO0. var config = I2SConfig () config . sample_rate = 44100 config . bits_per_sample = 16 config . comm_format = I2S_CHANNEL_FMT_RIGHT_LEFT config . channel_format = I2S_COMM_FORMAT_I2S config . mclk = 256 * 44100 i2s . install ( config )","title":"Example"},{"location":"plugins/scripting-language/#i2c","text":"Controls I2C bus on supported platforms. Mainly used in different drivers. Implemented by I2CDriver.cpp","title":"i2c"},{"location":"plugins/scripting-language/#commands_8","text":"Command Signature Supported platforms i2c.install (sda: int, scl: int) -> void Installs I2C driver under given pins. esp32 i2c.detect (addr:int) -> bool . Tries to detect device under given addr. Returns true if device found. esp32 i2c.read_bytes (addr:int, reg:int, size:int) -> int or nil . Read a value of 1..4 bytes from address addr and register reg. Returns nil if no response. esp32 i2c.write_bytes (addr:int, reg:int, val:bytes) -> nil Writes the val bytes sequence as bytes() to address addr register reg. esp32 i2c.read (addr:int, reg:int, size:int) -> int or nil . Reads a singular bytes from a given register. esp32 i2c.write (addr:int, reg:int, val:int) -> nil Writes a singular byte to a given register. esp32 i2c.write_raw (addr:int, val:bytes) -> nil Write a raw sequence of bytes to the given device. esp32 i2c.read_raw (addr:int, val:bytes, size: int) -> int or nil Writes the val sequence of bytes on the i2c line, and then reads size bytes. esp32","title":"Commands"},{"location":"plugins/scripting-language/#example_3","text":"Write few bytes to I2C device Configure I2C on 21 and 23 pins, then perform two writes. i2c . install ( 21 , 23 ) var deviceAddr = 0x10 # Write 0x01 to register 0x00 i2c . write ( deviceAddr , 0x00 , 0x01 ) # Write byte sequence to register 0x01 i2c . write_bytes ( deviceAddr , 0x01 , bytes ( '1a01' ))","title":"Example"},{"location":"plugins/scripting-language/#gpio","text":"Controls GPIO pins on supported platforms. Mainly used in different drivers. Implemented by GPIODriver.cpp","title":"gpio"},{"location":"plugins/scripting-language/#commands_9","text":"Command Signature Supported platforms gpio.digital_write (gpio: int, state: int) -> void Sets GPIO to LOW/HIGH. Needs physical pin number esp32 gpio.digital_read (gpio: int) -> int Returns digital state of given physical GPIO. Either gpio.LOW or gpio.HIGH esp32 gpio.pin_mode (gpio: int, mode: int) -> int Changes the GPIO mode. Only use if if you know what you're doing, by default Euphonium handles GPIO mode itself. Mode can have the following values: gpio.INPUT, gpio.OUTPUT, gpio.PULLUP, gpio.INPUT_PULLUP, gpio.PULLDOWN esp32 gpio.analog_read (gpio: int) -> real . Returns the voltage on a given pin in mV. Only used with DAC pins. esp32 gpio.register_button (gpio: int, event_type: gpio.EVENT_TYPE, handler: [() -> void], config: map([high_state: bool])) -> void Registers a new handler called after interaction with a given button on provided gpio . Supports press, double press, and long press. esp32","title":"Commands"},{"location":"plugins/scripting-language/#enum-inputevent_type","text":"Command Description Supported platforms gpio.PRESS Called on single press of a button. esp32 gpio.DOUBLE_PRESS Called on double press of a button. esp32 gpio.LONG_PRESS Called on long press of a button. esp32","title":"enum input.EVENT_TYPE"},{"location":"plugins/scripting-language/#example_4","text":"GPIO Driver usage Sets GPIO 21 as output, writes its state to HIGH. gpio . pin_mode ( 21 , gpio . OUTPUT ) gpio . digital_write ( 21 , gpio . HIGH )","title":"Example"},{"location":"plugins/scripting-language/#example_5","text":"Example button that changes volume when pressed Register a button on gpio 5, and call a function from playback when pressed. gpio . register_button ( 5 , input . PRESS , def () print ( \"Volume up called!\" ) playback . set_volume ( playback . volume + 5 ) end , { 'high_state' : true })","title":"Example"},{"location":"plugins/scripting-language/#led_strip","text":"Allows for control of addressable LEDs like the WS28xx and SK6812. Underneath it uses esp32's RMT driver, to drive up to 8 separate strip instances. Implemented by LEDDriver.cpp","title":"led_strip"},{"location":"plugins/scripting-language/#class-ledstrip","text":"Field Signature Supported platforms init / constructor (type: LED_TYPE, pin: int, len: int, channel: RMT_CHANNEL, brightness: int?) LEDStrip constructor. Allows control of a singular strip, with a driver type , connected under a GPIO pin . channel is the RMT channel to use. If brightness is provided, the entire LED chain will be dimmed accordingly. esp32 show () -> void Called on existing instance. Will update the LED strip with previously assigned color values esp32 set_item (index, item: [r: number, g: number, b: number]) -> void This implements the API for setting color of individual LEDs via a standard color assign. See example below for usage. r , g and b range from 0 to 255. esp32","title":"Class LEDStrip"},{"location":"plugins/scripting-language/#enum-led_stripled_type","text":"Value Description LED_WS2812 Indicates WS2812 LED type. LED_WS2812B Indicates WS2812B LED type. LED_SK6812 Indicates SK6812 LED type. LED_WS2813 Indicates WS2813 LED type.","title":"enum led_strip.LED_TYPE"},{"location":"plugins/scripting-language/#example_6","text":"LED Driver usage Registers a new LED strip under pin 21, consisting of 12 WS2812 leds, at lower brightness. Then turns the first LED red, the second one green. volume_strip = LEDStrip ( LED_WS2812 , 21 , 12 , RMT_CHANNEL_0 , 150 ) # change the first LED to red and second one to green. volume_strip [ 0 ] = [ 255 , 0 , 0 ] # red in RGB format volume_strip [ 1 ] = [ 0 , 255 , 0 ] # green in RGB format # display the changes on the strip volume_strip . show ()","title":"Example"},{"location":"plugins/scripting-language/#wifi","text":"Controls internal state of the platform's WiFi. Used internally by wifi.be . Implemented by WiFiDriver.cpp","title":"wifi"},{"location":"plugins/scripting-language/#commands_10","text":"Command Signature Supported platforms wifi.init_stack () -> void Initializes the WiFi stack esp32 wifi.connect (ssid: string, password: string, fromAP: bool) -> void Attempts WiFi connection. fromAP should be set according to the current WiFi mode. esp32 wifi.start_ap (ssid: string, password: string) -> void Starts an access point with given credentials. esp32 wifi.start_scan () -> boid . Starts scanning of WiFi networks. esp32","title":"Commands"},{"location":"technical/adding-new-dac/","text":"","title":"Adding support to new DAC"},{"location":"technical/adding-new-plugin/","text":"Extending Euphonium ~ Euphonium Architecture ~ There are essentially 4 layers of the Euphonium application which are: The Web UI written in React / Javascript The \"Application layer\" written in Berry Scripting language . A platform agnostic \"Feature layer\", written in C/C++ A platform Specific \"Driver layer\", written in C/C++ Plugins can integrate into each layer, and communicate between each layer. Having a firm understanding of how these layers communicate will help you understand what plugin's can do and what code you need to write when creating a new plugin. Web Plugins in Brief ~ Plugins can expose functionality the users in the Web Application via the make_form() method of the application layer plugin. Forms in the web app have two distinct functions: (1) exposing the current plugin state to the user, and (2) receiving inputs such as updated settings from users. The Web app is extended by creating an application layer plugin and creating a form using it's make_form() method. Additionally the Web app is a React (Vite) app located in the web/ directory that you can modify to your heart's content. Application Layer Plugins in Brief ~ Application layer plugins are written in Berry Scripting language and inherit from the Plugin Class Plugin scripts located in the euphonium/scripts/plugins and are used to define a new plugin class, instantiate the plugin and register it with Euphonium like so: class MyPlugin : Plugin def init () # Define constants like the plugin name end def make_form ( cts , state ) # Create the form that allows users to set plugin settings in the Web UI end def on_event ( event , data ) # Handle events, such as plugin initialization, updates to the plugin # state (in response to user interaction with the Web app) end end # Instantiate your plugin my_plugin = MyPlugin () # Register your plugin with the euphonium application euphonium . register_plugin ( my_plugin ) As of this writing, these are the events handled by the plugin's on_event() method: EVENT_CONFIG_UPDATED EVENT_VOLUME_UPDATED EVENT_SYSTEM_INIT EVENT_SET_PAUSE EVENT_PLUGIN_INIT Feature Layer Plugins in Brief ~ Feature plugin interfaces are defined in the euphonium/include/plugins/[pluginName] directories and the methods are defined (out of line) in the euphonium/src/plugins/[pluginName] directories. Feature plugins inherit from the Module and bell::Task classes. For the purposes creating plugins, bell::Task has the interface: class Task { public : std :: string taskName ; protected : // Override this to start your plugin task virtual void runTask () = 0 ; } and the Module class has this interface: class Module { public : Module () {} // constructor // Module name: std :: string name ; // Module Status: ModuleStatus status = ModuleStatus :: SHUTDOWN ; // A shared pointer to the berry runtime (vm) which can be used to expose // data and functions as to the berry runtime std :: shared_ptr < berry :: VmState > berry ; // A shared pointer to the luaEventBus where events can be posted to the // application from the plugin std :: shared_ptr < EventBus > luaEventBus ; // The audioBuffer std :: shared_ptr < MainAudioBuffer > audioBuffer ; // configuration managed by the berry :: map config ; // PLUGIN LIFE CYCLE METHODS: // ?? virtual void loadScript ( std :: shared_ptr < ScriptLoader > scriptLoader ) = 0 ; // Called by the Core application when the Berry runtime is ready to have // data and functions exported virtual void setupBindings () = 0 ; // ?? virtual void startAudioThread () = 0 ; // Called by the Core application at shut down virtual void shutdown () = 0 ; }; When Feature plugins are loaded, they are provided with a reference to the berry and luaEventBus , and then their setupBindings() method is called with the following: // euphonium/src/Core.cpp plugin -> berry = this -> berry ; plugin -> luaEventBus = this -> luaEventBus ; plugin -> setupBindings (); The berry and luaEventsBus are used to communicate with the application layer, as illustrated below. Driver Layer Plugins in Brief ~ Driver layer plugins (drivers, really) implement platform specific features and are located in the platform specific target/[platform] directories. For example, the I2C driver for the ESP32 is contained in the target/esp32/app/main/driver directory. Drivers are used to expose platform specific features (e.g. I2C) to the application layer. Communication between Euphonium Layers ~ Communication from Web Forms to Application Layer Plugins ~ The web forms in the settings section of the app communicate to the application layer via HTTP requests made to the /plugins/:name endpoint. When a POST request is made to this endpoint, the request body is used to update the plugin's state, and the plugin is notified that it's stat has been updated with a call to it's on_event() method like so: plugin . on_event ( EVENT_CONFIG_UPDATED , plugin . state ) Note that even though the new plugin stat is supplied as the second argument to this method call, the plugin's state has already been replaced before the method is called, so this invocation is merely an opportunity to respond to the state change; the method does not need to update it's own state in order for the state to be updated in this case. Application Layer Plugin HTTP APIs ~ Application layer plugins may expose API endpoints by registering a callback with the http plugin . Examples ~ Application Layer Plugin Example ~ This plugin toggles a pin LOW or HIGH in response to http POST requests made at a custom endpoint. Users can select the output pin on the in the web ap under the \"LED Driver\" settings. class LED_Driver : Plugin var pin def init () self . apply_default_values () self . name = \"led_driver\" self . theme_color = \"#d2c464\" self . display_name = \"LED Driver\" self . type = \"plugin\" end def make_form ( cts , state ) # Create the form that allows users select the output pin for the LED ctx . create_group ( 'led-driver' , { 'label' : 'General' }) ctx . number_field ( 'pin' , { 'label' : \"Output Pin\" , 'default' : \"0\" , 'group' : 'led-driver' , }) end def on_event ( event , data ) if event == EVENT_CONFIG_UPDATED if data . find ( 'pin' ) != nil && data [ 'pin' ] != '0' gpio . pin_mode ( self . state [ 'pin' ], gpio . INPUT_PULLUP ) end end if event == EVENT_PLUGIN_INIT if self . state . find ( 'pin' ) != nil && self . state [ 'pin' ] != '0' gpio . pin_mode ( self . state [ 'pin' ], gpio . INPUT_PULLUP ) end end end def set_pin ( pin_state ) # custom method to be called by the HTTP callback if self . state . find ( 'pin' ) == nil || self . state . pin == '0' # Output pin has not been set return end gpio . digital_write ( self . pin , pin_state ) end end # Instantiate the application layer plugin led_driver = LED_Driver () # Register the application layer plugin with the euphonium application euphonium . register_plugin ( CSpotPlugin ()) # Register the http endpoint http . handle ( \"POST\" , \"/toggle-pin\" , def if request . json_body () == 'true' led_driver . set_pin ( gpio . HIGH ) else led_driver . set_pin ( gpio . LOW ) end end ) The Event Bus ~ Communication within the Feature and to the Application layer can be achieved by posting messages to an Feature layer event bus. Messages posted to the Feature layer event bus are propagated to both Feature and application layer event subscribers. When Feature plugins are registered, a reference to the mainEventBus is bound to the plugin's luaEventBus property. Modules can therefor post events to the event bus using this -> luaEventBus -> postEvent ( std :: move ( event )); Feature layer plugins can subscribe to the event bus by registering a listener which implements the EventSubscriber interface. Plugins which implement an appropriate handleEvent() method can therefore register themselves as subscribers using: auto subscriber = dynamic_cast < EventSubscriber *> ( this ); luaEventBus -> addListener ( EventType :: LUA_MAIN_EVENT , * subscriber ); Notably the Euphonium Core registers itself as a subscriber, and uses that subscription to propagate events to the handle_event global in the application layer which then propagate those events to registered event handlers and plugins. Application layer plugins can receive events by registering a callback manually with the euphonium core using: euphonium . register_handler ( 'wifiStateChanged' , def ( event ) # Do something when the wifi state changes... end ) Note that only one handler register may be registered to a given event. Asynchronous tasks ~ Application may need to do tasks periodically, such as update a display, call out to a web server, etc. As of this writing, these types of tasks cannot be accomplished in the application layer as berry language is synchronous, and code like this will block the application indefinitely : # Do *not* to this: while 1 do_something () sleep_ms ( 1000 ) end Instead you'll need to create either a feature or driver plugin which inherits from bell::Task and runs your asynchronous tasks in a FreeRTOS task, like so: MyAwesomePlugin :: MyAwesomePlugin () : bell :: Task ( \"awesome\" , 6 * 1024 , 0 , 1 ) { name = \"awesome\" ; // create the FreeRTOS Task to run the `runTask()` method this -> startTask (); } void MyAwesomePlugin :: runTask () { while ( true ) // or any FreeRTOS idiom like `for(auto item: someQueue)` { do_something () vTaskDelay ( 1000 / portTICK_PERIOD_MS ); } } Exposing C++ Objects in the Berry language ~ While events can be propagated from the feature layer to the application layer, (as of this writing) the same mechanism cannot be used to communicate from the application layer to the feature layer. In order for the the feature layer to receive events from the application layer, feature plugins can bind functions, methods, and values into berry runtime. This is accomplished using the convenience methods of the berry reference that is attached to each feature plugin, such as: // bind the MQTTPlugin::publish method to mqqt.plugin function in the berry runtime berry -> export_this ( \"publish\" , this , & MQTTPlugin :: publish , \"mqtt\" ); // bind the gpioDigitalWrite function to gpio.digital_write function in the berry runtime berry -> export_function ( \"digital_write\" , & gpioDigitalWrite , \"gpio\" ); // bind the sleepMS function to sleep_ms global function in the berry runtime berry -> export_function ( \"sleep_ms\" , & sleepMS ); Installing Plugins ~ Installing Application layer plugins ~ The Berry scripts that define the application layer plugins are stored in the euphonium/scripts/plugin directory. Pro Tip: Start by creating a blank file ( my-plugin.be ) for your plugin, then compile, flash, and run the Euphonium application. This will create a new empty file in the that you can edit using the Web IDE. The Web IDE is a web application that you can run from your local machine, connect to your ESP32, edit your new plugin and debug your code in real time. When the plugin is working the way you like it, copy your code out of the web IDE and into your plugin's .be file. You can start the Web IDE by navigating to the /web-ide in the repo, with these commands: # install the dependencies (only required once) yarn install # Run the Web IDE application yarn start then Navigate to http://localhost:3000 (if the window doesn't open on it's own) to use the Web IDE Installing Feature layer (C/C++) plugins ~ Installing the .cpp and .h files: ~ Your plugin will need .h and .cpp files, which you can create with: pushd euphonium/src/plugins mkdir newFeature cd newFeature touch newFeaturePlugin.cpp popd and: pushd euphonium/include/plugins mkdir newFeature cd newFeature touch newFeaturePlugin.h popd Next, you'll need to tell the build system about the source files for your new plugin by adding to the list of glob patterns (e.g. \"src/plugins/my-plugin/*.cpp\" or \"src/plugins/my-plugin/*.c\" ) here in the same CMakeLists.txt file. You also need to add your include directory near the bottom of euphonium/CMakeLists.txt like so: include_directories ( \"include/plugins/my-plugin\" ) Finally, you'll need to add include your plugin's header file to euphonium/include/Core.cpp , and add your plugin to the list of registered plugins in euphonium/src/Core.cpp Using libraries with Feature Plugins ~ If your plugin is going to rely on existing external C/C++ libraries, then you'll need to load them into the repo (preferably as sub-modules), and tell the build system about the additional libraries. For example, if you want to library from github.com/some/great-library , then you'll want to clone in into euphonium/ with: git submodule add ../../some/great-library euphonium/great-library and then update euphonium/CMakeLists.txt with your dependency. Probably something like add_subdirectory ( ${ CMAKE_CURRENT_SOURCE_DIR } /bell ${ CMAKE_CURRENT_BINARY_DIR } /bell ) as well as adding your library to this lists in target_link_libraries() and target_include_directories() . A note of caution: Libraries that are aware of or depend on the esp-idf features are likely to flummox the build process if they are included in the euphonium core ( euphonium/ ) Installing Platform Specific Drivers ~ Platform specific drivers, will depend on the platform. New feature drivers for the ESP32, for example, can be installed with: pushd targets/esp32/app/main/driver mkdir feature cd feature touch featureDriver.cpp touch featureDriver.h popd Driver functionality should be exposed to the Application layer in the usual ways: Exporting C/C++ functions into the Berry language vm with the export helpers ( berry->export_something() ), which the ESP32 platform exposes to the drivers registers here create a plugin which inherits from bell::Task and register it as a plugin in main.cpp , which is how the Bluetooth Plugin is registered in the ESP32 target. Using ESP-IDF Libraries with (Drivers) ~ When writing drivers for the ESP32, the ESP-IDF will automatically include projects in the targets/esp32/app/components directory. For example, if you want to add a display using the awesome u8g2 library, you could add the required libraries as git submodules like so: git submodule add ../../olikraus/u8g2 targets/esp32/app/components/u8g2 git submodule add ../../mkfrey/u8g2-hal-esp-idf targets/esp32/app/components/u8g2-hal-esp-idf and like that, your new components can be consumed in your driver files.","title":"Writing your own plugin"},{"location":"technical/adding-new-plugin/#extending-euphonium","text":"","title":"Extending Euphonium"},{"location":"technical/adding-new-plugin/#euphonium-architecture","text":"There are essentially 4 layers of the Euphonium application which are: The Web UI written in React / Javascript The \"Application layer\" written in Berry Scripting language . A platform agnostic \"Feature layer\", written in C/C++ A platform Specific \"Driver layer\", written in C/C++ Plugins can integrate into each layer, and communicate between each layer. Having a firm understanding of how these layers communicate will help you understand what plugin's can do and what code you need to write when creating a new plugin.","title":"Euphonium Architecture"},{"location":"technical/adding-new-plugin/#web-plugins-in-brief","text":"Plugins can expose functionality the users in the Web Application via the make_form() method of the application layer plugin. Forms in the web app have two distinct functions: (1) exposing the current plugin state to the user, and (2) receiving inputs such as updated settings from users. The Web app is extended by creating an application layer plugin and creating a form using it's make_form() method. Additionally the Web app is a React (Vite) app located in the web/ directory that you can modify to your heart's content.","title":"Web Plugins in Brief"},{"location":"technical/adding-new-plugin/#application-layer-plugins-in-brief","text":"Application layer plugins are written in Berry Scripting language and inherit from the Plugin Class Plugin scripts located in the euphonium/scripts/plugins and are used to define a new plugin class, instantiate the plugin and register it with Euphonium like so: class MyPlugin : Plugin def init () # Define constants like the plugin name end def make_form ( cts , state ) # Create the form that allows users to set plugin settings in the Web UI end def on_event ( event , data ) # Handle events, such as plugin initialization, updates to the plugin # state (in response to user interaction with the Web app) end end # Instantiate your plugin my_plugin = MyPlugin () # Register your plugin with the euphonium application euphonium . register_plugin ( my_plugin ) As of this writing, these are the events handled by the plugin's on_event() method: EVENT_CONFIG_UPDATED EVENT_VOLUME_UPDATED EVENT_SYSTEM_INIT EVENT_SET_PAUSE EVENT_PLUGIN_INIT","title":"Application Layer Plugins in Brief"},{"location":"technical/adding-new-plugin/#feature-layer-plugins-in-brief","text":"Feature plugin interfaces are defined in the euphonium/include/plugins/[pluginName] directories and the methods are defined (out of line) in the euphonium/src/plugins/[pluginName] directories. Feature plugins inherit from the Module and bell::Task classes. For the purposes creating plugins, bell::Task has the interface: class Task { public : std :: string taskName ; protected : // Override this to start your plugin task virtual void runTask () = 0 ; } and the Module class has this interface: class Module { public : Module () {} // constructor // Module name: std :: string name ; // Module Status: ModuleStatus status = ModuleStatus :: SHUTDOWN ; // A shared pointer to the berry runtime (vm) which can be used to expose // data and functions as to the berry runtime std :: shared_ptr < berry :: VmState > berry ; // A shared pointer to the luaEventBus where events can be posted to the // application from the plugin std :: shared_ptr < EventBus > luaEventBus ; // The audioBuffer std :: shared_ptr < MainAudioBuffer > audioBuffer ; // configuration managed by the berry :: map config ; // PLUGIN LIFE CYCLE METHODS: // ?? virtual void loadScript ( std :: shared_ptr < ScriptLoader > scriptLoader ) = 0 ; // Called by the Core application when the Berry runtime is ready to have // data and functions exported virtual void setupBindings () = 0 ; // ?? virtual void startAudioThread () = 0 ; // Called by the Core application at shut down virtual void shutdown () = 0 ; }; When Feature plugins are loaded, they are provided with a reference to the berry and luaEventBus , and then their setupBindings() method is called with the following: // euphonium/src/Core.cpp plugin -> berry = this -> berry ; plugin -> luaEventBus = this -> luaEventBus ; plugin -> setupBindings (); The berry and luaEventsBus are used to communicate with the application layer, as illustrated below.","title":"Feature Layer Plugins in Brief"},{"location":"technical/adding-new-plugin/#driver-layer-plugins-in-brief","text":"Driver layer plugins (drivers, really) implement platform specific features and are located in the platform specific target/[platform] directories. For example, the I2C driver for the ESP32 is contained in the target/esp32/app/main/driver directory. Drivers are used to expose platform specific features (e.g. I2C) to the application layer.","title":"Driver Layer Plugins in Brief"},{"location":"technical/adding-new-plugin/#communication-between-euphonium-layers","text":"","title":"Communication between Euphonium Layers"},{"location":"technical/adding-new-plugin/#communication-from-web-forms-to-application-layer-plugins","text":"The web forms in the settings section of the app communicate to the application layer via HTTP requests made to the /plugins/:name endpoint. When a POST request is made to this endpoint, the request body is used to update the plugin's state, and the plugin is notified that it's stat has been updated with a call to it's on_event() method like so: plugin . on_event ( EVENT_CONFIG_UPDATED , plugin . state ) Note that even though the new plugin stat is supplied as the second argument to this method call, the plugin's state has already been replaced before the method is called, so this invocation is merely an opportunity to respond to the state change; the method does not need to update it's own state in order for the state to be updated in this case.","title":"Communication from Web Forms to Application Layer Plugins"},{"location":"technical/adding-new-plugin/#application-layer-plugin-http-apis","text":"Application layer plugins may expose API endpoints by registering a callback with the http plugin .","title":"Application Layer Plugin HTTP APIs"},{"location":"technical/adding-new-plugin/#examples","text":"","title":"Examples"},{"location":"technical/adding-new-plugin/#application-layer-plugin-example","text":"This plugin toggles a pin LOW or HIGH in response to http POST requests made at a custom endpoint. Users can select the output pin on the in the web ap under the \"LED Driver\" settings. class LED_Driver : Plugin var pin def init () self . apply_default_values () self . name = \"led_driver\" self . theme_color = \"#d2c464\" self . display_name = \"LED Driver\" self . type = \"plugin\" end def make_form ( cts , state ) # Create the form that allows users select the output pin for the LED ctx . create_group ( 'led-driver' , { 'label' : 'General' }) ctx . number_field ( 'pin' , { 'label' : \"Output Pin\" , 'default' : \"0\" , 'group' : 'led-driver' , }) end def on_event ( event , data ) if event == EVENT_CONFIG_UPDATED if data . find ( 'pin' ) != nil && data [ 'pin' ] != '0' gpio . pin_mode ( self . state [ 'pin' ], gpio . INPUT_PULLUP ) end end if event == EVENT_PLUGIN_INIT if self . state . find ( 'pin' ) != nil && self . state [ 'pin' ] != '0' gpio . pin_mode ( self . state [ 'pin' ], gpio . INPUT_PULLUP ) end end end def set_pin ( pin_state ) # custom method to be called by the HTTP callback if self . state . find ( 'pin' ) == nil || self . state . pin == '0' # Output pin has not been set return end gpio . digital_write ( self . pin , pin_state ) end end # Instantiate the application layer plugin led_driver = LED_Driver () # Register the application layer plugin with the euphonium application euphonium . register_plugin ( CSpotPlugin ()) # Register the http endpoint http . handle ( \"POST\" , \"/toggle-pin\" , def if request . json_body () == 'true' led_driver . set_pin ( gpio . HIGH ) else led_driver . set_pin ( gpio . LOW ) end end )","title":"Application Layer Plugin Example"},{"location":"technical/adding-new-plugin/#the-event-bus","text":"Communication within the Feature and to the Application layer can be achieved by posting messages to an Feature layer event bus. Messages posted to the Feature layer event bus are propagated to both Feature and application layer event subscribers. When Feature plugins are registered, a reference to the mainEventBus is bound to the plugin's luaEventBus property. Modules can therefor post events to the event bus using this -> luaEventBus -> postEvent ( std :: move ( event )); Feature layer plugins can subscribe to the event bus by registering a listener which implements the EventSubscriber interface. Plugins which implement an appropriate handleEvent() method can therefore register themselves as subscribers using: auto subscriber = dynamic_cast < EventSubscriber *> ( this ); luaEventBus -> addListener ( EventType :: LUA_MAIN_EVENT , * subscriber ); Notably the Euphonium Core registers itself as a subscriber, and uses that subscription to propagate events to the handle_event global in the application layer which then propagate those events to registered event handlers and plugins. Application layer plugins can receive events by registering a callback manually with the euphonium core using: euphonium . register_handler ( 'wifiStateChanged' , def ( event ) # Do something when the wifi state changes... end ) Note that only one handler register may be registered to a given event.","title":"The Event Bus"},{"location":"technical/adding-new-plugin/#asynchronous-tasks","text":"Application may need to do tasks periodically, such as update a display, call out to a web server, etc. As of this writing, these types of tasks cannot be accomplished in the application layer as berry language is synchronous, and code like this will block the application indefinitely : # Do *not* to this: while 1 do_something () sleep_ms ( 1000 ) end Instead you'll need to create either a feature or driver plugin which inherits from bell::Task and runs your asynchronous tasks in a FreeRTOS task, like so: MyAwesomePlugin :: MyAwesomePlugin () : bell :: Task ( \"awesome\" , 6 * 1024 , 0 , 1 ) { name = \"awesome\" ; // create the FreeRTOS Task to run the `runTask()` method this -> startTask (); } void MyAwesomePlugin :: runTask () { while ( true ) // or any FreeRTOS idiom like `for(auto item: someQueue)` { do_something () vTaskDelay ( 1000 / portTICK_PERIOD_MS ); } }","title":"Asynchronous tasks"},{"location":"technical/adding-new-plugin/#exposing-c-objects-in-the-berry-language","text":"While events can be propagated from the feature layer to the application layer, (as of this writing) the same mechanism cannot be used to communicate from the application layer to the feature layer. In order for the the feature layer to receive events from the application layer, feature plugins can bind functions, methods, and values into berry runtime. This is accomplished using the convenience methods of the berry reference that is attached to each feature plugin, such as: // bind the MQTTPlugin::publish method to mqqt.plugin function in the berry runtime berry -> export_this ( \"publish\" , this , & MQTTPlugin :: publish , \"mqtt\" ); // bind the gpioDigitalWrite function to gpio.digital_write function in the berry runtime berry -> export_function ( \"digital_write\" , & gpioDigitalWrite , \"gpio\" ); // bind the sleepMS function to sleep_ms global function in the berry runtime berry -> export_function ( \"sleep_ms\" , & sleepMS );","title":"Exposing C++ Objects in the Berry language"},{"location":"technical/adding-new-plugin/#installing-plugins","text":"","title":"Installing Plugins"},{"location":"technical/adding-new-plugin/#installing-application-layer-plugins","text":"The Berry scripts that define the application layer plugins are stored in the euphonium/scripts/plugin directory. Pro Tip: Start by creating a blank file ( my-plugin.be ) for your plugin, then compile, flash, and run the Euphonium application. This will create a new empty file in the that you can edit using the Web IDE. The Web IDE is a web application that you can run from your local machine, connect to your ESP32, edit your new plugin and debug your code in real time. When the plugin is working the way you like it, copy your code out of the web IDE and into your plugin's .be file. You can start the Web IDE by navigating to the /web-ide in the repo, with these commands: # install the dependencies (only required once) yarn install # Run the Web IDE application yarn start then Navigate to http://localhost:3000 (if the window doesn't open on it's own) to use the Web IDE","title":"Installing Application layer plugins"},{"location":"technical/adding-new-plugin/#installing-feature-layer-cc-plugins","text":"","title":"Installing Feature layer (C/C++) plugins"},{"location":"technical/adding-new-plugin/#installing-the-cpp-and-h-files","text":"Your plugin will need .h and .cpp files, which you can create with: pushd euphonium/src/plugins mkdir newFeature cd newFeature touch newFeaturePlugin.cpp popd and: pushd euphonium/include/plugins mkdir newFeature cd newFeature touch newFeaturePlugin.h popd Next, you'll need to tell the build system about the source files for your new plugin by adding to the list of glob patterns (e.g. \"src/plugins/my-plugin/*.cpp\" or \"src/plugins/my-plugin/*.c\" ) here in the same CMakeLists.txt file. You also need to add your include directory near the bottom of euphonium/CMakeLists.txt like so: include_directories ( \"include/plugins/my-plugin\" ) Finally, you'll need to add include your plugin's header file to euphonium/include/Core.cpp , and add your plugin to the list of registered plugins in euphonium/src/Core.cpp","title":"Installing the .cpp and .h files:"},{"location":"technical/adding-new-plugin/#using-libraries-with-feature-plugins","text":"If your plugin is going to rely on existing external C/C++ libraries, then you'll need to load them into the repo (preferably as sub-modules), and tell the build system about the additional libraries. For example, if you want to library from github.com/some/great-library , then you'll want to clone in into euphonium/ with: git submodule add ../../some/great-library euphonium/great-library and then update euphonium/CMakeLists.txt with your dependency. Probably something like add_subdirectory ( ${ CMAKE_CURRENT_SOURCE_DIR } /bell ${ CMAKE_CURRENT_BINARY_DIR } /bell ) as well as adding your library to this lists in target_link_libraries() and target_include_directories() . A note of caution: Libraries that are aware of or depend on the esp-idf features are likely to flummox the build process if they are included in the euphonium core ( euphonium/ )","title":"Using libraries with Feature Plugins"},{"location":"technical/adding-new-plugin/#installing-platform-specific-drivers","text":"Platform specific drivers, will depend on the platform. New feature drivers for the ESP32, for example, can be installed with: pushd targets/esp32/app/main/driver mkdir feature cd feature touch featureDriver.cpp touch featureDriver.h popd Driver functionality should be exposed to the Application layer in the usual ways: Exporting C/C++ functions into the Berry language vm with the export helpers ( berry->export_something() ), which the ESP32 platform exposes to the drivers registers here create a plugin which inherits from bell::Task and register it as a plugin in main.cpp , which is how the Bluetooth Plugin is registered in the ESP32 target.","title":"Installing Platform Specific Drivers"},{"location":"technical/adding-new-plugin/#using-esp-idf-libraries-with-drivers","text":"When writing drivers for the ESP32, the ESP-IDF will automatically include projects in the targets/esp32/app/components directory. For example, if you want to add a display using the awesome u8g2 library, you could add the required libraries as git submodules like so: git submodule add ../../olikraus/u8g2 targets/esp32/app/components/u8g2 git submodule add ../../mkfrey/u8g2-hal-esp-idf targets/esp32/app/components/u8g2-hal-esp-idf and like that, your new components can be consumed in your driver files.","title":"Using ESP-IDF Libraries with (Drivers)"},{"location":"technical/architecture/","text":"Architecture ~ Plugins ~ Scripting language structure ~ The following table describes folder structure of the internal scripting file system. Folder internal ~ Rewritten by OTA Contains the core of the application. This handles the central classes, main http endpoints, and is the main entrypoint. File Description internal/init.be Main entrypoint of the script loader. Do not add your extensions here, please see extensions.be . internal/api.be Implementation of the main Euphonium REST API. internal/bindings.be Shallow binding classes that allow for communication between Berry and C++. internal/euphonium.be Main Euphonium class which handles system initialization, event handling and plugin registration. internal/http.be Sugar syntax wrapper over the native HTTP server. internal/app-version Text file containing current version, needed for OTA. Folder vendor ~ Rewritten by manufacturer OTA Contains vendor-specific code. This allows for customization of euphonium for different manufacturers. Code here is rewritten with every manufacturer OTA. vendor/init.be - Entry point for all vendor-specific code. Rest of the code here is product-specific. Folder configuration ~ Contains saved configuration of the app in form of *.config.json files. Folder esp32 ~ Contains the ESP32 platform support. TODO: Describe structure . Folder extensions ~ Contains all user scripts. These are loaded last, after all other scripts. You can register your custom driver by appending to extensions.be file.","title":"Architecture"},{"location":"technical/architecture/#architecture","text":"","title":"Architecture"},{"location":"technical/architecture/#plugins","text":"","title":"Plugins"},{"location":"technical/architecture/#scripting-language-structure","text":"The following table describes folder structure of the internal scripting file system.","title":"Scripting language structure"},{"location":"technical/architecture/#folder-internal","text":"Rewritten by OTA Contains the core of the application. This handles the central classes, main http endpoints, and is the main entrypoint. File Description internal/init.be Main entrypoint of the script loader. Do not add your extensions here, please see extensions.be . internal/api.be Implementation of the main Euphonium REST API. internal/bindings.be Shallow binding classes that allow for communication between Berry and C++. internal/euphonium.be Main Euphonium class which handles system initialization, event handling and plugin registration. internal/http.be Sugar syntax wrapper over the native HTTP server. internal/app-version Text file containing current version, needed for OTA.","title":"Folder internal"},{"location":"technical/architecture/#folder-vendor","text":"Rewritten by manufacturer OTA Contains vendor-specific code. This allows for customization of euphonium for different manufacturers. Code here is rewritten with every manufacturer OTA. vendor/init.be - Entry point for all vendor-specific code. Rest of the code here is product-specific.","title":"Folder vendor"},{"location":"technical/architecture/#folder-configuration","text":"Contains saved configuration of the app in form of *.config.json files.","title":"Folder configuration"},{"location":"technical/architecture/#folder-esp32","text":"Contains the ESP32 platform support. TODO: Describe structure .","title":"Folder esp32"},{"location":"technical/architecture/#folder-extensions","text":"Contains all user scripts. These are loaded last, after all other scripts. You can register your custom driver by appending to extensions.be file.","title":"Folder extensions"},{"location":"technical/dev-environment/","text":"Setup ~ The best way to try euphonium is to flash a prebuilt version. However, if you want to build it yourself, or help out with development, you will need a few dependencies to get this project to build. Checkout code ~ When checking out the repository, use --recursive to retrieve all submodules. Alternately, after checkout use git submodule update --init --recursive to perform the same task. git clone --recursive https://github.com/feelfreelinux/euphonium Setting up web UI bundler ~ First, a required step is to setup all of the dependencies required to build the web UI. python ~ Python needs to be installed on your system. Ensure that you have pip installed. This can be done by python -m ensurepip --upgrade Then we can install the needed dependencies by using the requirements.txt file. Execute this command to install the needed dependencies (from the root of the project): pip install -r requirements.txt nodejs ~ you need at least version 14. Precompiled distrobution packages with installation instructions can be found here: https://github.com/nodesource/distributions npm ~ Npm should be included in the nodesource package. Otherwise the installation is platform specific, but mostly just comes down to installing it through a package manager. yarn ~ be careful: don't install yarn from default package repository on Debian or Ubuntu. It would install the package cmdtest for you. To be sure you may run sudo apt remove cmdtest first. The right package can be installed with: corepack enable yarn set version stablerm -rf bu Setting up dependencies for target platform ~ Depending on the target platform, (esp32 or cli) the dependencies are differnt. Desktop specific dependencies ~ PortAudio library OpenSSL library both can be installed with a package manager. If you are on macOS then we can do this with brew : brew install OpenSSL PortAudio If you are on Ubuntu/Debian you can install with: sudo apt install libmbedtls-dev protobuf-compiler openssl libasound-dev portaudio19-dev libportaudio2 libportaudiocpp0 Needed libs on Linux ~ When building on linux you will also need the follwoing dependency: libavahi-compat-libdnssd-dev . This can be installed by sudo apt-get install libavahi-compat-libdnssd-dev ESP32-Specific dependencies ~ esp-idf in version 4.4.1 . Please follow Espressif's guide . As an alternative you can install VSCode (https://code.visualstudio.com/) and open the euphonium folder. VSCode should recommend the following extensions to you: - \"espressif.esp-idf-extension\" - \"platformio.platformio-ide\" (optional) - \"berry.berry\" (optional) In this case the installation of ESP-IDF is managed by vscode. If the extensions are installed you can open the ESP-IDF terminal ( STRG + E followed by T ) and continue building as described below. Hint for Linux Mint ~ In order for the CLI build to work on Linux Mint I had to add a little extra CLI arg to the cmake command, as it doesn't know how to find the correct library it would seem. Maybe this could be added directly into the cmake setup? To fully compile the cli on Linux Mint execute the following cmake -DCMAKE_CXX_STANDARD_LIBRARIES=\"-ldl\" .. make Building and installing the project - Desktop ~ For a desktop run, please run the following commands Setup cd targets/cli mkdir build && cd build cmake .. Build make This will output a binary euphoniumcli which can be later executed to run the platform. The web-ui will be available on port 80 by default. If you have trouble using port 80 (on Linux for example), use cmake .. -D HTTP_SERVER_PORT=8080 to change the web-ui port. Building and installing the project - ESP32 ~ For ESP32 target, please run following commands (with esp-idf in the PATH) Setup cd targets/esp32 sh build_recovery.sh sh build_app.sh Build For full flash: sh flash_all.sh {serialport} For app-only flash: sh reflash_app.sh {serialport} For spiffs only flash (berry scripts, webui, configuration): sh reflash_spiffs.sh {serialport} Development improvements ~ There are a few tricks to make the development faster Preconfiguration of WIFI and DAC ~ Every flash of the spiffs partition will reset the internal configuration. It's a bit of a pain when dealing with esp32, as you have to deal with reconfiguration of the system through the AP network with every flash. To avoid this, you can preconfigure the WiFi settings (any any other setting!) to be included in the flashed partition. To configure WiFi, create a file inside of euphonium/scripts/configuration folder, named wifi.config.json , containing following data { \"ssid\": \"YOUR NETWORK SSID\", \"password\": \" YOUR NETWORK PASSWORD\" } After rerunning the reflash_spiffs script WiFi is going to be preconfigured :)","title":"Setting up development environment"},{"location":"technical/dev-environment/#setup","text":"The best way to try euphonium is to flash a prebuilt version. However, if you want to build it yourself, or help out with development, you will need a few dependencies to get this project to build.","title":"Setup"},{"location":"technical/dev-environment/#checkout-code","text":"When checking out the repository, use --recursive to retrieve all submodules. Alternately, after checkout use git submodule update --init --recursive to perform the same task. git clone --recursive https://github.com/feelfreelinux/euphonium","title":"Checkout code"},{"location":"technical/dev-environment/#setting-up-web-ui-bundler","text":"First, a required step is to setup all of the dependencies required to build the web UI.","title":"Setting up web UI bundler"},{"location":"technical/dev-environment/#python","text":"Python needs to be installed on your system. Ensure that you have pip installed. This can be done by python -m ensurepip --upgrade Then we can install the needed dependencies by using the requirements.txt file. Execute this command to install the needed dependencies (from the root of the project): pip install -r requirements.txt","title":"python"},{"location":"technical/dev-environment/#nodejs","text":"you need at least version 14. Precompiled distrobution packages with installation instructions can be found here: https://github.com/nodesource/distributions","title":"nodejs"},{"location":"technical/dev-environment/#npm","text":"Npm should be included in the nodesource package. Otherwise the installation is platform specific, but mostly just comes down to installing it through a package manager.","title":"npm"},{"location":"technical/dev-environment/#yarn","text":"be careful: don't install yarn from default package repository on Debian or Ubuntu. It would install the package cmdtest for you. To be sure you may run sudo apt remove cmdtest first. The right package can be installed with: corepack enable yarn set version stablerm -rf bu","title":"yarn"},{"location":"technical/dev-environment/#setting-up-dependencies-for-target-platform","text":"Depending on the target platform, (esp32 or cli) the dependencies are differnt.","title":"Setting up dependencies for target platform"},{"location":"technical/dev-environment/#desktop-specific-dependencies","text":"PortAudio library OpenSSL library both can be installed with a package manager. If you are on macOS then we can do this with brew : brew install OpenSSL PortAudio If you are on Ubuntu/Debian you can install with: sudo apt install libmbedtls-dev protobuf-compiler openssl libasound-dev portaudio19-dev libportaudio2 libportaudiocpp0","title":"Desktop specific dependencies"},{"location":"technical/dev-environment/#building-and-installing-the-project-desktop","text":"For a desktop run, please run the following commands Setup cd targets/cli mkdir build && cd build cmake .. Build make This will output a binary euphoniumcli which can be later executed to run the platform. The web-ui will be available on port 80 by default. If you have trouble using port 80 (on Linux for example), use cmake .. -D HTTP_SERVER_PORT=8080 to change the web-ui port.","title":"Building and installing the project - Desktop"},{"location":"technical/dev-environment/#building-and-installing-the-project-esp32","text":"For ESP32 target, please run following commands (with esp-idf in the PATH) Setup cd targets/esp32 sh build_recovery.sh sh build_app.sh Build For full flash: sh flash_all.sh {serialport} For app-only flash: sh reflash_app.sh {serialport} For spiffs only flash (berry scripts, webui, configuration): sh reflash_spiffs.sh {serialport}","title":"Building and installing the project - ESP32"},{"location":"technical/dev-environment/#development-improvements","text":"There are a few tricks to make the development faster","title":"Development improvements"},{"location":"technical/dev-environment/#preconfiguration-of-wifi-and-dac","text":"Every flash of the spiffs partition will reset the internal configuration. It's a bit of a pain when dealing with esp32, as you have to deal with reconfiguration of the system through the AP network with every flash. To avoid this, you can preconfigure the WiFi settings (any any other setting!) to be included in the flashed partition. To configure WiFi, create a file inside of euphonium/scripts/configuration folder, named wifi.config.json , containing following data { \"ssid\": \"YOUR NETWORK SSID\", \"password\": \" YOUR NETWORK PASSWORD\" } After rerunning the reflash_spiffs script WiFi is going to be preconfigured :)","title":"Preconfiguration of WIFI and DAC"},{"location":"technical/tasks/","text":"Tasks - esp32 specific ~ The following table lists all of internal FreeRtos tasks running in Euphonium, along with their core affinity and stack size. Core / system ~ Task name Type Stack size Core affinity Priority PSRAM wifi system - 0 - No bluetooth system - 1 - No euphonium core 8192 0 2 No Core core 4096 0 2 Yes http plugin 6144 0 1 No persistor plugin 4096 1 0 No CSpot - plugin ~ Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback. Considerations ~ Due to internal use of hardware AES, AudioChunkManager needs to be ran on same core as wifi . Task name Stack size Core affinity Priority PSRAM Always active CSpotPlugin 4096 1 0 Yes Yes MercuryManager 6144 1 1 Yes No AudioChunkManager 4096 0 1 Yes No Player 10240 1 0 Yes No Web Radio - plugin ~ Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback. Task name Stack size Core affinity Priority PSRAM Always active WebRadioPlugin 6144 1 1 Yes Yes","title":"Tasks - esp32 specific"},{"location":"technical/tasks/#tasks-esp32-specific","text":"The following table lists all of internal FreeRtos tasks running in Euphonium, along with their core affinity and stack size.","title":"Tasks - esp32 specific"},{"location":"technical/tasks/#core-system","text":"Task name Type Stack size Core affinity Priority PSRAM wifi system - 0 - No bluetooth system - 1 - No euphonium core 8192 0 2 No Core core 4096 0 2 Yes http plugin 6144 0 1 No persistor plugin 4096 1 0 No","title":"Core / system"},{"location":"technical/tasks/#cspot-plugin","text":"Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback.","title":"CSpot - plugin"},{"location":"technical/tasks/#considerations","text":"Due to internal use of hardware AES, AudioChunkManager needs to be ran on same core as wifi . Task name Stack size Core affinity Priority PSRAM Always active CSpotPlugin 4096 1 0 Yes Yes MercuryManager 6144 1 1 Yes No AudioChunkManager 4096 0 1 Yes No Player 10240 1 0 Yes No","title":"Considerations"},{"location":"technical/tasks/#web-radio-plugin","text":"Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback. Task name Stack size Core affinity Priority PSRAM Always active WebRadioPlugin 6144 1 1 Yes Yes","title":"Web Radio - plugin"}]}